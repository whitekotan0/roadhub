<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoadHub - Visual Editor</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { 
      overflow: hidden; 
      user-select: none; /* Отключаем выделение текста глобально */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    .editor-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      height: 100vh;
    }
    
    /* Inputs должны иметь возможность выделения */
    input, textarea {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    #roadmapProps {
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      margin-bottom: var(--spacing-lg);
    }
    
    #roadmapProps.collapsed {
      max-height: 60px;
      overflow: hidden;
      cursor: pointer;
    }
    
    #roadmapProps.collapsed:hover {
      background: rgba(255, 255, 255, 0.08);
    }
    
    .collapse-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
    }
    
    .collapse-icon {
      transition: transform var(--transition-base);
    }
    
    #roadmapProps.collapsed .collapse-icon {
      transform: rotate(-90deg);
    }
    
    #nodeProps {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--spacing-lg);
      min-height: 0;
    }
    
    .color-picker-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .color-input-group {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    .color-preview {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: var(--shadow-md);
    }
    
    .color-preview:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow-lg);
    }
    
    .color-controls {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .color-input-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .color-input-wrapper input[type="text"] {
      flex: 1;
      font-family: monospace;
      text-transform: uppercase;
      padding: 10px;
    }
    
    .color-input-wrapper input[type="range"] {
      flex: 1;
    }
    
    input[type="color"] {
      width: 100%;
      height: 42px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      background: none;
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(to right, transparent, var(--accent-primary));
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-primary);
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-primary);
      cursor: pointer;
      border: none;
      box-shadow: var(--shadow-md);
    }
    
    /* Improved port styling */
    .port {
      cursor: crosshair !important;
      pointer-events: all !important;
    }
    
    .port.active {
      fill: var(--accent-success) !important;
      stroke: var(--accent-success) !important;
      r: 10 !important;
      filter: drop-shadow(0 0 8px var(--accent-success)) !important;
    }
    
    .temp-link {
      pointer-events: none !important;
    }
    
    .close-node-btn {
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: all 400ms var(--spring);
    }
    
    .close-node-btn:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: var(--accent-danger);
      transform: scale(1.1) rotate(90deg);
    }
    
    .close-node-btn:active {
      transform: scale(0.95) rotate(90deg);
    }
  </style>
</head>
<body>
  <button class="theme-btn" onclick="toggleTheme()" id="theme-btn" aria-label="Toggle theme">
    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
      <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"/>
    </svg>
  </button>
  
  <div class="editor-layout">
    <div id="canvas-area">
      <div class="editor-toolbar">
        <a href="index.html" style="display: flex; align-items: center; gap: 10px; padding: 10px 16px; border-radius: 8px; font-weight: 600;">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 0L0 8l8 8 1.5-1.5L3 8l6.5-6.5z"/>
          </svg>
          <span>Home</span>
        </a>
        <button onclick="addNewNode()" class="btn btn-primary" style="padding: 10px 20px;">
          Add Node
        </button>
        <button onclick="centerView()" class="btn btn-glass" style="padding: 10px 20px;">
          Center
        </button>
        <button onclick="downloadJSON()" class="btn btn-success" style="padding: 10px 20px;">
          Save
        </button>
        <button onclick="loadJSON()" class="btn btn-glass" style="padding: 10px 20px;">
          Load
        </button>
        <input type="file" id="load-input" accept=".json" style="display: none;" onchange="handleFileLoad(this)">
      </div>
      
      <div class="node-counter">
        Nodes: <strong id="node-count">0</strong> | Links: <strong id="link-count">0</strong>
      </div>
      
      <div class="zoom-controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">−</button>
        <button onclick="resetZoom()">⌂</button>
      </div>
      
      <svg id="svg"></svg>
    </div>

    <div class="properties-panel" id="propPanel">
      <h2>RoadHub Editor</h2>
      
      <div id="roadmapProps" class="collapsed">
        <div class="collapse-header" onclick="toggleRoadmapSettings()">
          <span style="font-weight: 700; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted);">
            Roadmap Settings
          </span>
          <span class="collapse-icon" style="font-size: 20px;">▼</span>
        </div>
        
        <div style="margin-top: var(--spacing-md);">
          <div class="form-group">
            <label>Roadmap Title</label>
            <input type="text" id="mapTitle" value="New Roadmap" oninput="updateMeta()" placeholder="Enter title">
          </div>
          
          <div class="form-group">
            <label>Unique ID</label>
            <input type="text" id="mapId" value="custom_map" oninput="updateMeta()" placeholder="custom_map">
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="mapDescription" rows="2" oninput="updateMeta()" placeholder="Short description..."></textarea>
          </div>
        </div>
      </div>

      <div id="nodeProps" style="display:none;">
        <div style="padding: var(--spacing-md); background: var(--surface-glass); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: var(--radius-lg); display: flex; justify-content: space-between; align-items: center;">
          <h3 style="margin: 0; font-size: 1.25rem; font-weight: 700;">
            Edit Node
          </h3>
          <button onclick="closeNodePanel()" class="close-node-btn" aria-label="Close">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
              <path d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"/>
            </svg>
          </button>
        </div>
        
        <div class="form-group">
          <label>Node Title</label>
          <input type="text" id="nodeTitle" oninput="updateActiveNode()" placeholder="Node title" style="font-size: 16px; padding: 16px;">
        </div>
        
        <div class="form-group">
          <label>Node Color & Opacity</label>
          <div class="color-picker-section">
            <div class="color-input-group">
              <div id="colorPreview" class="color-preview"></div>
              <div class="color-controls">
                <input type="color" id="nodeColor" onchange="updateNodeColor()" value="#667eea">
                <div class="color-input-wrapper">
                  <span style="font-size: 12px; color: var(--text-muted); min-width: 60px;">Opacity:</span>
                  <input type="range" id="nodeOpacity" min="0" max="100" value="70" oninput="updateNodeColor()">
                  <span id="opacityValue" style="font-size: 12px; color: var(--text-muted); min-width: 35px;">70%</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="form-group" style="flex: 1; min-height: 0; display: flex; flex-direction: column;">
          <label>Description</label>
          <textarea id="nodeContent" oninput="updateActiveNode()" placeholder="Enter description..." style="flex: 1; min-height: 200px; font-size: 14px; line-height: 1.6;"></textarea>
        </div>
        
        <div class="form-group">
          <label>Connected From</label>
          <div id="prerequisites-list" style="max-height: 120px; overflow-y: auto; padding: 12px; background: var(--bg-tertiary); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px;">
            <p style="color: var(--text-muted); font-size: 12px; margin: 0;">No connections</p>
          </div>
        </div>

        <button onclick="deleteSelectedNode()" class="btn btn-danger" style="width: 100%; justify-content: center; padding: 16px; font-size: 16px;">
          Delete Node
        </button>
      </div>
      
      <div class="info-box" id="helpBox" style="margin-top: auto;">
        <p style="margin: 0; font-size: 12px; line-height: 1.6;">
          <b>Quick Tips:</b><br>
          • Drag from port to port to connect<br>
          • Click on line to delete it<br>
          • Ctrl+N - new node<br>
          • Ctrl+S - save
        </p>
      </div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <script>
    function toggleTheme() {
      document.body.classList.toggle('light-theme');
      const isLight = document.body.classList.contains('light-theme');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      updateThemeIcon();
    }
    
    function updateThemeIcon() {
      const isLight = document.body.classList.contains('light-theme');
      const btn = document.getElementById('theme-btn');
      btn.innerHTML = isLight ? 
        '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"/></svg>' :
        '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"/></svg>';
    }
    
    if(localStorage.getItem('theme') === 'light') {
      document.body.classList.add('light-theme');
    }
    updateThemeIcon();
    
    function toggleRoadmapSettings() {
      document.getElementById('roadmapProps').classList.toggle('collapsed');
    }

    const NODE_W = 200;
    const NODE_H = 90;

    let roadmapData = { 
      id: "custom_map", 
      title: "New Roadmap", 
      description: "",
      nodes: [] 
    };
    
    let svg, gNodes, gLinks, zoom, container;
    let selectedNodeId = null;
    let drawingLine = null;
    let activePort = null;
    let selectedLink = null;
    
    const PORTS = [
      [NODE_W/2, 0, 'top'],
      [NODE_W, NODE_H/2, 'right'],
      [NODE_W/2, NODE_H, 'bottom'],
      [0, NODE_H/2, 'left']
    ];

    function init() {
      container = document.getElementById('canvas-area');
      svg = d3.select("#svg").attr("width", "100%").attr("height", "100%");
      
      // Prevent text selection on SVG
      svg.on("mousedown", () => {
        d3.event?.preventDefault?.();
      });
      
      const defs = svg.append("defs");
      // Убрали стрелки (треугольники)

      const gContainer = svg.append("g");
      gLinks = gContainer.append("g");
      gNodes = gContainer.append("g");
      
      const tempPath = gContainer.append("path").attr("class", "temp-link").attr("d", "");

      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", e => gContainer.attr("transform", e.transform));
      svg.call(zoom).on("dblclick.zoom", null);
      
      svg.on("mousemove", e => {
        if(drawingLine) {
          const [mx, my] = d3.pointer(e, gContainer.node());
          tempPath.attr("d", `M${drawingLine.startX},${drawingLine.startY} L${mx},${my}`);
        }
      });

      svg.on("mouseup", (e) => {
        if(drawingLine) {
          // If mouseup not on a port, cancel drawing
          if (!d3.select(e.target).classed('port')) {
            console.log('Cancelled drawing - mouseup not on port');
            drawingLine = null;
            tempPath.attr("d", "");
            gNodes.selectAll('.port').classed('active', false);
          }
        }
      });

      svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
      render();
      updateCounts();
    }

    function hexToRgba(hex, opacity) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity / 100})`;
    }

    function updateNodeColor() {
      if(!selectedNodeId) return;
      
      const color = document.getElementById('nodeColor').value;
      const opacity = document.getElementById('nodeOpacity').value;
      const rgba = hexToRgba(color, opacity);
      
      document.getElementById('opacityValue').textContent = opacity + '%';
      document.getElementById('colorPreview').style.background = rgba;
      
      const node = roadmapData.nodes.find(x => x.id === selectedNodeId);
      node.color = color;
      node.opacity = parseFloat(opacity) / 100;
      
      render();
    }

    function render() {
      const links = [];
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) {
          n.prerequisites.forEach(p => {
            let sourceId, sourcePort, targetPort;
            
            // Поддержка старого и нового формата
            if (typeof p === 'object') {
              sourceId = p.nodeId;
              sourcePort = p.sourcePort;
              targetPort = p.targetPort;
            } else {
              sourceId = p;
              sourcePort = null;
              targetPort = null;
            }
            
            const src = roadmapData.nodes.find(x => x.id === sourceId);
            if(src) links.push({ src, tgt: n, sourcePort, targetPort });
          });
        }
      });

      const linkSel = gLinks.selectAll(".link").data(links, d => d.src.id + "-" + d.tgt.id + "-" + (d.sourcePort || 'auto'));
      linkSel.exit().remove();
      
      linkSel.enter().append("path")
        .attr("class", "link")
        .style("cursor", "pointer")
        .on("click", function(e, d) { 
          e.stopPropagation();
          selectLink(this, d);
        })
        .on("contextmenu", (e, d) => { e.preventDefault(); deleteLink(d); })
        .merge(linkSel)
        .attr("d", d => calculateBezier(d.src, d.tgt, d.sourcePort, d.targetPort));

      const nodeSel = gNodes.selectAll(".node-group").data(roadmapData.nodes, d => d.id);
      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter().append("g")
        .attr("class", "node-group")
        .call(d3.drag()
          .on("start", dragStart)
          .on("drag", dragging)
          .on("end", dragEnd));

      nodeEnter.append("rect")
        .attr("class", "body")
        .attr("width", NODE_W)
        .attr("height", NODE_H)
        .attr("rx", 14);

      nodeEnter.append("text")
        .attr("x", NODE_W/2)
        .attr("y", NODE_H/2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none")
        .style("fill", "var(--text-primary)")
        .style("font-size", "14px")
        .style("font-weight", "600");

      // Port creation with proper data binding
      PORTS.forEach((p, idx) => {
        nodeEnter.append("circle")
          .attr("class", "port")
          .attr("cx", p[0])
          .attr("cy", p[1])
          .attr("r", 8)
          .attr("data-port", p[2]) // Добавляем имя порта
          .style("pointer-events", "all")
          .on("mousedown", function(e, nodeData) {
            e.stopPropagation();
            e.preventDefault();
            startDrawing(nodeData, p);
          })
          .on("mouseup", function(e, nodeData) {
            e.stopPropagation();
            e.preventDefault();
            if (drawingLine) {
              finishDrawing(nodeData, p);
            }
          })
          .on("mouseenter", function() {
            if (drawingLine) {
              d3.select(this).classed('active', true);
            }
          })
          .on("mouseleave", function() {
            d3.select(this).classed('active', false);
          });
      });

      const allNodes = nodeEnter.merge(nodeSel);
      allNodes.attr("transform", d => `translate(${d.x}, ${d.y})`);
      allNodes.classed("selected", d => d.id === selectedNodeId);
      
      allNodes.select("rect.body")
        .style("fill", d => {
          const color = d.color || '#667eea';
          const opacity = d.opacity !== undefined ? d.opacity : 0.7;
          return hexToRgba(color, opacity * 100);
        })
        .style("stroke", d => d.color || '#667eea');
      
      allNodes.select("text").text(d => {
        const maxLen = 22;
        return d.title.length > maxLen ? d.title.substr(0, maxLen-3) + '...' : d.title;
      });
      
      allNodes.on("click", (e, d) => {
        if (!drawingLine) {
          e.stopPropagation();
          selectNode(d.id);
        }
      });
      
      updateCounts();
    }

    function calculateBezier(src, tgt, sourcePort, targetPort) {
      // Если порты указаны, используем их. Иначе автоматический расчет
      let start, end;
      
      if (sourcePort && targetPort) {
        // Используем сохраненные порты
        const srcPortData = PORTS.find(p => p[2] === sourcePort);
        const tgtPortData = PORTS.find(p => p[2] === targetPort);
        
        if (srcPortData && tgtPortData) {
          start = { x: src.x + srcPortData[0], y: src.y + srcPortData[1] };
          end = { x: tgt.x + tgtPortData[0], y: tgt.y + tgtPortData[1] };
        }
      }
      
      // Фоллбэк на автоматический расчет если портов нет
      if (!start || !end) {
        const sx = src.x + NODE_W/2, sy = src.y + NODE_H/2;
        const tx = tgt.x + NODE_W/2, ty = tgt.y + NODE_H/2;
        const dx = tx - sx, dy = ty - sy;
        
        start = {x: sx, y: src.y + NODE_H};
        end = {x: tx, y: tgt.y};
        
        if (Math.abs(dx) > Math.abs(dy)) {
          start = dx > 0 ? {x: src.x + NODE_W, y: sy} : {x: src.x, y: sy};
          end = dx > 0 ? {x: tgt.x, y: ty} : {x: tgt.x + NODE_W, y: ty};
        } else {
          start = dy > 0 ? {x: sx, y: src.y + NODE_H} : {x: sx, y: src.y};
          end = dy > 0 ? {x: tx, y: tgt.y} : {x: tx, y: tgt.y + NODE_H};
        }
      }
      
      const dx = end.x - start.x;
      const dy = end.y - start.y;
      const dist = Math.sqrt(dx*dx + dy*dy) * 0.5;
      
      return Math.abs(dy) > Math.abs(dx) 
        ? `M${start.x},${start.y} C${start.x},${start.y + dist} ${end.x},${end.y - dist} ${end.x},${end.y}`
        : `M${start.x},${start.y} C${start.x + dist},${start.y} ${end.x - dist},${end.y} ${end.x},${end.y}`;
    }

    function startDrawing(nodeData, port) {
      const node = roadmapData.nodes.find(n => n.id === nodeData.id);
      if (!node) return;
      
      drawingLine = { 
        sourceId: node.id,
        sourcePort: port, // Сохраняем порт источника
        startX: node.x + port[0], 
        startY: node.y + port[1] 
      };
      
      console.log('Started drawing from node:', node.id, 'port:', port[2]);
    }

    function finishDrawing(targetNodeData, targetPort) {
      if (!drawingLine) return;
      
      const targetNode = roadmapData.nodes.find(n => n.id === targetNodeData.id);
      if (!targetNode) {
        console.log('Target node not found');
        drawingLine = null;
        d3.select(".temp-link").attr("d", "");
        return;
      }
      
      if (drawingLine.sourceId === targetNode.id) {
        console.log('Cannot connect node to itself');
        drawingLine = null;
        d3.select(".temp-link").attr("d", "");
        return;
      }
      
      if (!targetNode.prerequisites) targetNode.prerequisites = [];
      
      // Проверяем, нет ли уже такой связи
      const existingLink = targetNode.prerequisites.find(p => 
        typeof p === 'object' ? p.nodeId === drawingLine.sourceId : p === drawingLine.sourceId
      );
      
      if (!existingLink) {
        // Сохраняем информацию о портах
        targetNode.prerequisites.push({
          nodeId: drawingLine.sourceId,
          sourcePort: drawingLine.sourcePort[2], // название порта (top, right, bottom, left)
          targetPort: targetPort[2]
        });
        console.log('Created link from', drawingLine.sourceId, 'to', targetNode.id);
        render();
      } else {
        console.log('Link already exists');
      }
      
      drawingLine = null;
      d3.select(".temp-link").attr("d", "");
      gNodes.selectAll('.port').classed('active', false);
    }

    function dragStart(e, d) { 
      d3.select(this).raise(); 
      selectNode(d.id); 
    }
    
    function dragging(e, d) { 
      d.x = e.x; 
      d.y = e.y; 
      d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`); 
      render(); 
    }
    
    function dragEnd(e, d) {}

    function addNewNode() {
      const id = "node_" + Date.now();
      roadmapData.nodes.push({
        id, 
        title: "New Node", 
        color: '#667eea',
        opacity: 0.7,
        content: "",
        prerequisites: [], 
        x: container.clientWidth / 2 - NODE_W/2, 
        y: container.clientHeight / 2 - NODE_H/2
      });
      render();
      selectNode(id);
    }

    function selectNode(id) {
      selectedNodeId = id;
      const n = roadmapData.nodes.find(x => x.id === id);
      if(!n) return;

      document.getElementById('roadmapProps').classList.add('collapsed');
      document.getElementById('nodeProps').style.display = 'flex';
      document.getElementById('helpBox').style.display = 'none';
      
      document.getElementById('nodeTitle').value = n.title;
      document.getElementById('nodeContent').value = n.content || '';
      
      // Update color picker
      const color = n.color || '#667eea';
      const opacity = (n.opacity !== undefined ? n.opacity : 0.7) * 100;
      
      document.getElementById('nodeColor').value = color;
      document.getElementById('nodeOpacity').value = opacity;
      document.getElementById('opacityValue').textContent = Math.round(opacity) + '%';
      document.getElementById('colorPreview').style.background = hexToRgba(color, opacity);
      
      render();
      updatePrerequisitesList();
    }

    function updatePrerequisitesList() {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (!node) return;
      const list = document.getElementById('prerequisites-list');
      const prereqs = (node.prerequisites || []).map(p => {
        const id = typeof p === 'object' ? p.nodeId : p;
        const prereqNode = roadmapData.nodes.find(n => n.id === id);
        return { id, title: prereqNode ? prereqNode.title : id };
      });
      if (prereqs.length === 0) {
        list.innerHTML = '<p style="color: var(--text-muted); font-size: 12px; margin: 0;">No connections</p>';
      } else {
        list.innerHTML = prereqs.map((p, idx) => {
          return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 6px;">
            <span style="font-size: 13px; color: var(--text-primary);">${p.title}</span>
            <button onclick="removePrerequisite(${idx})" class="btn btn-danger" style="padding: 4px 10px; font-size: 12px;">×</button>
          </div>`;
        }).join('');
      }
    }

    function removePrerequisite(idx) {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (node?.prerequisites) {
        node.prerequisites.splice(idx, 1);
        render();
        updatePrerequisitesList();
      }
    }

    function updateActiveNode() {
      if(!selectedNodeId) return;
      const n = roadmapData.nodes.find(x => x.id === selectedNodeId);
      n.title = document.getElementById('nodeTitle').value;
      n.content = document.getElementById('nodeContent').value;
      render();
    }
    
    function closeNodePanel() {
      selectedNodeId = null;
      document.getElementById('nodeProps').style.display = 'none';
      document.getElementById('roadmapProps').classList.remove('collapsed');
      document.getElementById('helpBox').style.display = 'block';
      render();
    }

    function deleteSelectedNode() {
      if(!selectedNodeId || !confirm("Delete this node?")) return;
      roadmapData.nodes = roadmapData.nodes.filter(n => n.id !== selectedNodeId);
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) n.prerequisites = n.prerequisites.filter(p => p !== selectedNodeId);
      });
      selectedNodeId = null;
      document.getElementById('nodeProps').style.display = 'none';
      document.getElementById('roadmapProps').classList.remove('collapsed');
      document.getElementById('helpBox').style.display = 'block';
      render();
    }

    function selectLink(linkElement, data) {
      // Deselect previous
      if (selectedLink) {
        d3.select(selectedLink).classed('selected', false);
      }
      
      selectedLink = linkElement;
      d3.select(linkElement).classed('selected', true);
      
      // Show delete button or just delete immediately
      if (confirm('Delete this connection?')) {
        deleteLink(data);
        selectedLink = null;
      } else {
        d3.select(linkElement).classed('selected', false);
        selectedLink = null;
      }
    }
    
    function deleteLink(data) {
      const tgt = roadmapData.nodes.find(n => n.id === data.tgt.id);
      if (tgt?.prerequisites) {
        tgt.prerequisites = tgt.prerequisites.filter(p => {
          if (typeof p === 'object') {
            return p.nodeId !== data.src.id;
          }
          return p !== data.src.id;
        });
        render();
        if (selectedNodeId === data.tgt.id) updatePrerequisitesList();
      }
    }

    function downloadJSON() {
      const blob = new Blob([JSON.stringify(roadmapData, null, 2)], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (roadmapData.title || 'roadmap').replace(/\s+/g, '_') + ".json";
      a.click();
    }

    function loadJSON() { document.getElementById('load-input').click(); }

    function handleFileLoad(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const json = JSON.parse(e.target.result);
          if (!json.nodes) throw new Error('Invalid format');
          roadmapData = json;
          selectedNodeId = null;
          document.getElementById('mapTitle').value = json.title || 'Roadmap';
          document.getElementById('mapId').value = json.id || 'custom_map';
          document.getElementById('mapDescription').value = json.description || '';
          document.getElementById('nodeProps').style.display = 'none';
          document.getElementById('roadmapProps').classList.remove('collapsed');
          document.getElementById('helpBox').style.display = 'block';
          render();
        } catch (err) { alert("Error: " + err.message); }
      };
      reader.readAsText(file);
    }

    function updateMeta() {
      roadmapData.title = document.getElementById('mapTitle').value;
      roadmapData.id = document.getElementById('mapId').value;
      roadmapData.description = document.getElementById('mapDescription').value;
    }

    function updateCounts() {
      document.getElementById('node-count').textContent = roadmapData.nodes.length;
      document.getElementById('link-count').textContent = roadmapData.nodes.reduce((sum, n) => sum + (n.prerequisites?.length || 0), 0);
    }

    function centerView() {
      if (roadmapData.nodes.length === 0) {
        svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
        return;
      }
      const bounds = roadmapData.nodes.reduce((acc, n) => ({
        minX: Math.min(acc.minX, n.x), maxX: Math.max(acc.maxX, n.x + NODE_W),
        minY: Math.min(acc.minY, n.y), maxY: Math.max(acc.maxY, n.y + NODE_H)
      }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
      const w = bounds.maxX - bounds.minX, h = bounds.maxY - bounds.minY;
      const cx = bounds.minX + w/2, cy = bounds.minY + h/2;
      const scale = Math.min((container.clientWidth * 0.8) / w, (container.clientHeight * 0.8) / h, 1);
      svg.transition().duration(750).call(zoom.transform, 
        d3.zoomIdentity.translate(container.clientWidth/2 - cx*scale, container.clientHeight/2 - cy*scale).scale(scale));
    }

    function zoomIn() { svg.transition().call(zoom.scaleBy, 1.2); }
    function zoomOut() { svg.transition().call(zoom.scaleBy, 0.8); }
    function resetZoom() { svg.transition().call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8)); }

    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === 'Delete' || e.key === 'Backspace') { if (selectedNodeId) deleteSelectedNode(); }
      else if (e.key === 'n' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); addNewNode(); }
      else if (e.key === 's' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); downloadJSON(); }
    });

    init();
  </script>
</body>
</html>

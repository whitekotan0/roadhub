<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roadmap Architect - Visual Editor</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { overflow: hidden; }
  </style>
</head>
<body>
  <button class="theme-btn" onclick="toggleTheme()" id="theme-btn" aria-label="Toggle theme">‚òÄÔ∏è</button>
  
  <div class="editor-layout">
    <div id="canvas-area">
      <div class="editor-toolbar">
        <a href="index.html" style="display: flex; align-items: center; gap: 10px; padding: 10px 16px; border-radius: 8px; font-weight: 600; transition: all 0.2s;">
          ‚Üê Home
        </a>
        <button onclick="addNewNode()" class="btn btn-primary" style="padding: 10px 20px;">
          + Node
        </button>
        <button onclick="centerView()" class="btn btn-glass" style="padding: 10px 20px;" title="Center view">
          üéØ
        </button>
        <button onclick="downloadJSON()" class="btn btn-success" style="padding: 10px 20px;">
          üíæ Save
        </button>
        <button onclick="loadJSON()" class="btn btn-glass" style="padding: 10px 20px;">
          üìÇ Load
        </button>
        <input type="file" id="load-input" accept=".json" style="display: none;" onchange="handleFileLoad(this)">
      </div>
      
      <div class="node-counter">
        Nodes: <strong id="node-count">0</strong> | Links: <strong id="link-count">0</strong>
      </div>
      
      <div class="zoom-controls">
        <button onclick="zoomIn()" title="Zoom in">+</button>
        <button onclick="zoomOut()" title="Zoom out">‚àí</button>
        <button onclick="resetZoom()" title="Reset zoom">‚åÇ</button>
      </div>
      
      <svg id="svg"></svg>
    </div>

    <div class="properties-panel" id="propPanel">
      <h2>‚öôÔ∏è Settings</h2>
      
      <div id="roadmapProps">
        <div class="form-group">
          <label>Roadmap Title</label>
          <input type="text" id="mapTitle" value="New Roadmap" oninput="updateMeta()" placeholder="Enter title">
        </div>
        
        <div class="form-group">
          <label>Unique ID</label>
          <input type="text" id="mapId" value="custom_map" oninput="updateMeta()" placeholder="custom_map">
        </div>
        
        <div class="form-group">
          <label>Description (Optional)</label>
          <textarea id="mapDescription" rows="3" oninput="updateMeta()" placeholder="Short description..."></textarea>
        </div>
        
        <div class="info-box">
          <p>
            <b>Creating Connections:</b><br>
            Drag from any <span style="color: var(--accent-success)">‚óè port</span> on a node to another node.<br><br>
            <b>Deleting Links:</b><br>
            Hover over a line and Shift+Click or Right-click.<br><br>
            <b>Deleting Nodes:</b><br>
            Select a node and click "Delete" button below.<br><br>
            <b>Keyboard Shortcuts:</b><br>
            ‚Ä¢ Ctrl+N - New node<br>
            ‚Ä¢ Ctrl+S - Save<br>
            ‚Ä¢ Delete - Remove node
          </p>
        </div>
      </div>

      <div id="nodeProps" style="display:none; flex-direction: column; gap: 20px;">
        <hr style="border:0; border-top:1px solid rgba(255, 255, 255, 0.1); margin: 16px 0;">
        
        <div class="form-group">
          <label>Node Title</label>
          <input type="text" id="nodeTitle" oninput="updateActiveNode()" placeholder="Node title">
        </div>
        
        <div class="form-group">
          <label>Type / Color</label>
          <select id="nodeGroup" onchange="updateActiveNode()">
            <option value="core">Core (Blue)</option>
            <option value="gamedev">Game Dev (Green)</option>
            <option value="ml">AI / ML (Purple)</option>
            <option value="crypto">Crypto (Orange)</option>
            <option value="engineering">Engineering (Red)</option>
            <option value="research">Research (Pink)</option>
          </select>
        </div>

        <div class="form-group">
          <label>Description (Markdown)</label>
          <textarea id="nodeContent" style="height: 220px;" oninput="updateActiveNode()" placeholder="# Heading&#10;&#10;Node description...&#10;&#10;- Point 1&#10;- Point 2"></textarea>
          <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px;">
            Supports Markdown: # headers, **bold**, *italic*, - lists
          </small>
        </div>
        
        <div class="form-group">
          <label>Prerequisites</label>
          <div id="prerequisites-list" style="min-height: 60px; padding: 12px; background: var(--bg-tertiary); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; margin-top: 8px;">
            <p style="color: var(--text-muted); font-size: 12px; margin: 0;">Select nodes to create links</p>
          </div>
        </div>

        <button onclick="deleteSelectedNode()" class="btn btn-danger" style="width: 100%; justify-content: center; margin-top: auto;">
          üóëÔ∏è Delete Node
        </button>
      </div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <script>
    // Theme
    function toggleTheme() {
      document.body.classList.toggle('light-theme');
      const isLight = document.body.classList.toggle('light-theme');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      document.getElementById('theme-btn').textContent = isLight ? 'üåô' : '‚òÄÔ∏è';
    }
    
    if(localStorage.getItem('theme') === 'light') {
      document.body.classList.add('light-theme');
      document.getElementById('theme-btn').textContent = 'üåô';
    }

    // CONFIG
    const NODE_W = 200;
    const NODE_H = 90;

    // DATA STATE
    let roadmapData = { 
      id: "custom_map", 
      title: "New Roadmap", 
      description: "",
      nodes: [] 
    };
    
    // UI STATE
    let svg, gNodes, gLinks, zoom, container;
    let selectedNodeId = null;
    let drawingLine = null;
    let currentZoom = 1;
    
    const PORTS = [
      [NODE_W/2, 0, 'top'],
      [NODE_W, NODE_H/2, 'right'],
      [NODE_W/2, NODE_H, 'bottom'],
      [0, NODE_H/2, 'left']
    ];

    // INIT
    function init() {
      container = document.getElementById('canvas-area');
      svg = d3.select("#svg").attr("width", "100%").attr("height", "100%");
      
      const defs = svg.append("defs");
      
      // Gradient arrow
      const arrowGrad = defs.append("linearGradient")
        .attr("id", "arrow-grad")
        .attr("x1", "0%").attr("y1", "0%")
        .attr("x2", "100%").attr("y2", "0%");
      
      arrowGrad.append("stop").attr("offset", "0%").attr("stop-color", "var(--accent-primary)").attr("stop-opacity", 0.5);
      arrowGrad.append("stop").attr("offset", "100%").attr("stop-color", "var(--accent-primary)").attr("stop-opacity", 1);
      
      defs.append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "url(#arrow-grad)");

      const gContainer = svg.append("g");
      gLinks = gContainer.append("g");
      gNodes = gContainer.append("g");
      
      const tempPath = gContainer.append("path").attr("class", "temp-link").attr("d", "");

      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", e => {
          gContainer.attr("transform", e.transform);
          currentZoom = e.transform.k;
        });
      svg.call(zoom).on("dblclick.zoom", null);
      
      svg.on("mousemove", e => {
        if(drawingLine) {
          const [mx, my] = d3.pointer(e, gContainer.node());
          tempPath.attr("d", `M${drawingLine.startX},${drawingLine.startY} L${mx},${my}`);
        }
      });

      svg.on("mouseup", (e) => {
        if(drawingLine) {
          const [mx, my] = d3.pointer(e, gContainer.node());
          const targetNode = findNodeAtPosition(mx, my);
          if (targetNode && targetNode.id !== drawingLine.sourceId) {
            finishDrawing(targetNode);
          } else {
            drawingLine = null;
            tempPath.attr("d", "");
          }
        }
      });

      svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
      render();
      updateCounts();
    }

    function findNodeAtPosition(x, y) {
      return roadmapData.nodes.find(n => {
        return x >= n.x && x <= n.x + NODE_W &&
               y >= n.y && y <= n.y + NODE_H;
      });
    }

    function render() {
      const links = [];
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) {
          n.prerequisites.forEach(pId => {
            const src = roadmapData.nodes.find(x => x.id === pId);
            if(src) links.push({ src, tgt: n });
          });
        }
      });

      const linkSel = gLinks.selectAll(".link").data(links, d => d.src.id + "-" + d.tgt.id);
      linkSel.exit().remove();
      
      linkSel.enter().append("path")
        .attr("class", "link")
        .attr("marker-end", "url(#arrow)")
        .on("click", (e, d) => {
          if (e.shiftKey) deleteLink(d);
        })
        .on("contextmenu", (e, d) => {
          e.preventDefault();
          deleteLink(d);
        })
        .merge(linkSel)
        .attr("d", d => calculateBezier(d.src, d.tgt));

      const nodeSel = gNodes.selectAll(".node-group").data(roadmapData.nodes, d => d.id);
      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter().append("g")
        .attr("class", "node-group")
        .call(d3.drag().on("start", dragStart).on("drag", dragging).on("end", dragEnd));

      nodeEnter.append("rect")
        .attr("class", "body")
        .attr("width", NODE_W)
        .attr("height", NODE_H)
        .attr("rx", 14);

      nodeEnter.append("text")
        .attr("x", NODE_W/2)
        .attr("y", NODE_H/2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none")
        .style("fill", "var(--text-primary)")
        .style("font-size", "14px")
        .style("font-weight", "600");

      PORTS.forEach(p => {
        nodeEnter.append("circle")
          .attr("class", "port")
          .attr("cx", p[0])
          .attr("cy", p[1])
          .attr("r", 6)
          .on("mousedown", (e, d) => {
            e.stopPropagation();
            startDrawing(e, d, p);
          });
      });

      const allNodes = nodeEnter.merge(nodeSel);
      allNodes.attr("transform", d => `translate(${d.x}, ${d.y})`);
      allNodes.attr("data-group", d => d.group || 'core');
      allNodes.classed("selected", d => d.id === selectedNodeId);
      allNodes.select("text").text(d => {
        const maxLen = 22;
        return d.title.length > maxLen ? d.title.substr(0, maxLen-3) + '...' : d.title;
      });
      
      allNodes.on("click", (e, d) => {
        e.stopPropagation();
        selectNode(d.id);
      });
      
      updateCounts();
    }

    function calculateBezier(src, tgt) {
      const sx = src.x + NODE_W/2;
      const sy = src.y + NODE_H/2;
      const tx = tgt.x + NODE_W/2;
      const ty = tgt.y + NODE_H/2;
      const dx = tx - sx;
      const dy = ty - sy;
      
      let start = {x: sx, y: src.y + NODE_H};
      let end = {x: tx, y: tgt.y};

      if (Math.abs(dx) > Math.abs(dy)) {
        if(dx > 0) {
          start = {x: src.x + NODE_W, y: sy};
          end = {x: tgt.x, y: ty};
        } else {
          start = {x: src.x, y: sy};
          end = {x: tgt.x + NODE_W, y: ty};
        }
      } else {
        if(dy > 0) {
          start = {x: sx, y: src.y + NODE_H};
          end = {x: tx, y: tgt.y};
        } else {
          start = {x: sx, y: src.y};
          end = {x: tx, y: tgt.y + NODE_H};
        }
      }

      const dist = Math.sqrt(dx*dx + dy*dy) * 0.5;
      
      if (Math.abs(dy) > Math.abs(dx)) {
        return `M${start.x},${start.y} C${start.x},${start.y + dist} ${end.x},${end.y - dist} ${end.x},${end.y}`;
      } else {
        return `M${start.x},${start.y} C${start.x + dist},${start.y} ${end.x - dist},${end.y} ${end.x},${end.y}`;
      }
    }

    function startDrawing(e, d, port) {
      e.stopPropagation();
      const startX = d.x + port[0];
      const startY = d.y + port[1];
      drawingLine = { sourceId: d.id, startX, startY };
    }

    function finishDrawing(targetNode) {
      if (!drawingLine) return;
      const sourceId = drawingLine.sourceId;
      const targetId = targetNode.id;
      if (sourceId === targetId) {
        drawingLine = null;
        d3.select(".temp-link").attr("d", "");
        return;
      }
      const targetNodeData = roadmapData.nodes.find(n => n.id === targetId);
      if (!targetNodeData.prerequisites) targetNodeData.prerequisites = [];
      if (!targetNodeData.prerequisites.includes(sourceId)) {
        targetNodeData.prerequisites.push(sourceId);
        render();
      }
      drawingLine = null;
      d3.select(".temp-link").attr("d", "");
    }

    function dragStart(e, d) {
      d3.select(this).raise();
      selectNode(d.id);
    }
    
    function dragging(e, d) {
      d.x = e.x;
      d.y = e.y;
      d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`);
      render();
    }
    
    function dragEnd(e, d) {}

    function addNewNode() {
      const id = "node_" + Date.now();
      const centerX = container.clientWidth / 2;
      const centerY = container.clientHeight / 2;
      
      roadmapData.nodes.push({
        id,
        title: "New Node",
        group: "core",
        content: "# New Node\n\nDescription...",
        prerequisites: [],
        x: centerX - NODE_W/2,
        y: centerY - NODE_H/2
      });
      render();
      selectNode(id);
    }

    function selectNode(id) {
      selectedNodeId = id;
      render();
      const n = roadmapData.nodes.find(x => x.id === id);
      if(!n) return;

      document.getElementById('roadmapProps').style.display = 'none';
      document.getElementById('nodeProps').style.display = 'flex';
      
      document.getElementById('nodeTitle').value = n.title;
      document.getElementById('nodeGroup').value = n.group || 'core';
      document.getElementById('nodeContent').value = n.content || '';
      
      updatePrerequisitesList();
    }

    function updatePrerequisitesList() {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (!node) return;
      
      const list = document.getElementById('prerequisites-list');
      const prereqs = (node.prerequisites || []).map(pId => {
        const prereqNode = roadmapData.nodes.find(n => n.id === pId);
        return prereqNode ? prereqNode.title : pId;
      });
      
      if (prereqs.length === 0) {
        list.innerHTML = '<p style="color: var(--text-muted); font-size: 12px; margin: 0;">No prerequisites</p>';
      } else {
        list.innerHTML = prereqs.map((title, idx) => {
          const pId = node.prerequisites[idx];
          return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 6px;">
            <span style="font-size: 13px; color: var(--text-primary);">${title}</span>
            <button onclick="removePrerequisite('${pId}')" class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;">√ó</button>
          </div>`;
        }).join('');
      }
    }

    function removePrerequisite(pId) {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (node && node.prerequisites) {
        node.prerequisites = node.prerequisites.filter(id => id !== pId);
        render();
        updatePrerequisitesList();
      }
    }

    function updateActiveNode() {
      if(!selectedNodeId) return;
      const n = roadmapData.nodes.find(x => x.id === selectedNodeId);
      n.title = document.getElementById('nodeTitle').value;
      n.group = document.getElementById('nodeGroup').value;
      n.content = document.getElementById('nodeContent').value;
      render();
    }

    function deleteSelectedNode() {
      if(!selectedNodeId) return;
      if (!confirm("Delete this node? All connections will also be removed.")) return;
      
      roadmapData.nodes = roadmapData.nodes.filter(n => n.id !== selectedNodeId);
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) n.prerequisites = n.prerequisites.filter(p => p !== selectedNodeId);
      });
      selectedNodeId = null;
      document.getElementById('nodeProps').style.display = 'none';
      document.getElementById('roadmapProps').style.display = 'block';
      render();
    }

    function deleteLink(data) {
      const tgt = roadmapData.nodes.find(n => n.id === data.tgt.id);
      if (tgt && tgt.prerequisites) {
        tgt.prerequisites = tgt.prerequisites.filter(pid => pid !== data.src.id);
        render();
        if (selectedNodeId === data.tgt.id) updatePrerequisitesList();
      }
    }

    function downloadJSON() {
      const dataStr = JSON.stringify(roadmapData, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = (document.getElementById('mapTitle').value || 'roadmap').replace(/\s+/g, '_') + ".json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function loadJSON() {
      document.getElementById('load-input').click();
    }

    function handleFileLoad(input) {
      const file = input.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const json = JSON.parse(e.target.result);
          if (!json.nodes || !Array.isArray(json.nodes)) {
            throw new Error('Invalid format: expected "nodes" array');
          }
          
          roadmapData = json;
          selectedNodeId = null;
          document.getElementById('mapTitle').value = json.title || 'Roadmap';
          document.getElementById('mapId').value = json.id || 'custom_map';
          document.getElementById('mapDescription').value = json.description || '';
          document.getElementById('nodeProps').style.display = 'none';
          document.getElementById('roadmapProps').style.display = 'block';
          render();
        } catch (err) {
          alert("Loading error: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    function updateMeta() {
      roadmapData.title = document.getElementById('mapTitle').value;
      roadmapData.id = document.getElementById('mapId').value;
      roadmapData.description = document.getElementById('mapDescription').value;
    }

    function updateCounts() {
      document.getElementById('node-count').textContent = roadmapData.nodes.length;
      const linkCount = roadmapData.nodes.reduce((sum, n) => sum + (n.prerequisites?.length || 0), 0);
      document.getElementById('link-count').textContent = linkCount;
    }

    function centerView() {
      if (roadmapData.nodes.length === 0) {
        svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
        return;
      }
      
      const bounds = roadmapData.nodes.reduce((acc, n) => {
        return {
          minX: Math.min(acc.minX, n.x),
          maxX: Math.max(acc.maxX, n.x + NODE_W),
          minY: Math.min(acc.minY, n.y),
          maxY: Math.max(acc.maxY, n.y + NODE_H)
        };
      }, { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
      
      const width = bounds.maxX - bounds.minX;
      const height = bounds.maxY - bounds.minY;
      const centerX = bounds.minX + width / 2;
      const centerY = bounds.minY + height / 2;
      
      const scale = Math.min(
        (container.clientWidth * 0.8) / width,
        (container.clientHeight * 0.8) / height,
        1
      );
      
      svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity
        .translate(container.clientWidth / 2 - centerX * scale, container.clientHeight / 2 - centerY * scale)
        .scale(scale));
    }

    function zoomIn() {
      svg.transition().call(zoom.scaleBy, 1.2);
    }

    function zoomOut() {
      svg.transition().call(zoom.scaleBy, 0.8);
    }

    function resetZoom() {
      svg.transition().call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedNodeId) deleteSelectedNode();
      } else if (e.key === 'n' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        addNewNode();
      } else if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        downloadJSON();
      }
    });

    init();
  </script>
</body>
</html>

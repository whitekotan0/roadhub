<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RoadHub - Visual Editor</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { 
      overflow: hidden; 
      user-select: none; /* –û—Ç–∫–ª—é—á–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≥–ª–æ–±–∞–ª—å–Ω–æ */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    .editor-layout {
      display: grid;
      grid-template-columns: 1fr 360px;
      height: 100vh;
    }
    
    /* Inputs –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏—è */
    input, textarea {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
    
    #roadmapProps {
      background: var(--surface-glass);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      margin-bottom: var(--spacing-lg);
    }
    
    #roadmapProps.collapsed {
      max-height: 60px;
      overflow: hidden;
      cursor: pointer;
    }
    
    #roadmapProps.collapsed:hover {
      background: rgba(255, 255, 255, 0.08);
    }
    
    .collapse-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      user-select: none;
    }
    
    .collapse-icon {
      transition: transform var(--transition-base);
    }
    
    #roadmapProps.collapsed .collapse-icon {
      transform: rotate(-90deg);
    }
    
    #nodeProps {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--spacing-lg);
      min-height: 0;
    }
    
    .color-picker-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .color-input-group {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    
    .color-preview {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: var(--shadow-md);
    }
    
    .color-preview:hover {
      transform: scale(1.05);
      box-shadow: var(--shadow-lg);
    }
    
    .color-controls {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .color-input-wrapper {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .color-input-wrapper input[type="text"] {
      flex: 1;
      font-family: monospace;
      text-transform: uppercase;
      padding: 10px;
    }
    
    .color-input-wrapper input[type="range"] {
      flex: 1;
    }
    
    input[type="color"] {
      width: 100%;
      height: 42px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      background: none;
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: linear-gradient(to right, transparent, var(--accent-primary));
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-primary);
      cursor: pointer;
      box-shadow: var(--shadow-md);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent-primary);
      cursor: pointer;
      border: none;
      box-shadow: var(--shadow-md);
    }
    
    /* Improved port styling */
    .port {
      cursor: crosshair !important;
      pointer-events: all !important;
    }
    
    .port.active {
      fill: var(--accent-success) !important;
      stroke: var(--accent-success) !important;
      r: 10 !important;
      filter: drop-shadow(0 0 8px var(--accent-success)) !important;
    }
    
    .temp-link {
      pointer-events: none !important;
    }
  </style>
</head>
<body>
  <button class="theme-btn" onclick="toggleTheme()" id="theme-btn" aria-label="Toggle theme">‚òÄÔ∏è</button>
  
  <div class="editor-layout">
    <div id="canvas-area">
      <div class="editor-toolbar">
        <a href="index.html" style="display: flex; align-items: center; gap: 10px; padding: 10px 16px; border-radius: 8px; font-weight: 600;">
          ‚Üê Home
        </a>
        <button onclick="addNewNode()" class="btn btn-primary" style="padding: 10px 20px;">
          + Node
        </button>
        <button onclick="centerView()" class="btn btn-glass" style="padding: 10px 20px;">
          üéØ
        </button>
        <button onclick="downloadJSON()" class="btn btn-success" style="padding: 10px 20px;">
          üíæ Save
        </button>
        <button onclick="loadJSON()" class="btn btn-glass" style="padding: 10px 20px;">
          üìÇ Load
        </button>
        <input type="file" id="load-input" accept=".json" style="display: none;" onchange="handleFileLoad(this)">
      </div>
      
      <div class="node-counter">
        Nodes: <strong id="node-count">0</strong> | Links: <strong id="link-count">0</strong>
      </div>
      
      <div class="zoom-controls">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">‚àí</button>
        <button onclick="resetZoom()">‚åÇ</button>
      </div>
      
      <svg id="svg"></svg>
    </div>

    <div class="properties-panel" id="propPanel">
      <h2>‚öôÔ∏è RoadHub Editor</h2>
      
      <div id="roadmapProps" class="collapsed">
        <div class="collapse-header" onclick="toggleRoadmapSettings()">
          <span style="font-weight: 700; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-muted);">
            Roadmap Settings
          </span>
          <span class="collapse-icon" style="font-size: 20px;">‚ñº</span>
        </div>
        
        <div style="margin-top: var(--spacing-md);">
          <div class="form-group">
            <label>Roadmap Title</label>
            <input type="text" id="mapTitle" value="New Roadmap" oninput="updateMeta()" placeholder="Enter title">
          </div>
          
          <div class="form-group">
            <label>Unique ID</label>
            <input type="text" id="mapId" value="custom_map" oninput="updateMeta()" placeholder="custom_map">
          </div>
          
          <div class="form-group">
            <label>Description</label>
            <textarea id="mapDescription" rows="2" oninput="updateMeta()" placeholder="Short description..."></textarea>
          </div>
        </div>
      </div>

      <div id="nodeProps" style="display:none;">
        <div style="padding: var(--spacing-md); background: var(--surface-glass); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: var(--radius-lg);">
          <h3 style="margin: 0; font-size: 1.25rem; font-weight: 700;">
            ‚úèÔ∏è Edit Node
          </h3>
        </div>
        
        <div class="form-group">
          <label>Node Title</label>
          <input type="text" id="nodeTitle" oninput="updateActiveNode()" placeholder="Node title" style="font-size: 16px; padding: 16px;">
        </div>
        
        <div class="form-group">
          <label>Node Color & Opacity</label>
          <div class="color-picker-section">
            <div class="color-input-group">
              <div id="colorPreview" class="color-preview"></div>
              <div class="color-controls">
                <input type="color" id="nodeColor" onchange="updateNodeColor()" value="#667eea">
                <div class="color-input-wrapper">
                  <span style="font-size: 12px; color: var(--text-muted); min-width: 60px;">Opacity:</span>
                  <input type="range" id="nodeOpacity" min="0" max="100" value="70" oninput="updateNodeColor()">
                  <span id="opacityValue" style="font-size: 12px; color: var(--text-muted); min-width: 35px;">70%</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="form-group" style="flex: 1; min-height: 0; display: flex; flex-direction: column;">
          <label>Description (Markdown)</label>
          <textarea id="nodeContent" oninput="updateActiveNode()" placeholder="# Heading&#10;&#10;Node description...&#10;&#10;- Point 1&#10;- Point 2" style="flex: 1; min-height: 200px; font-size: 14px; line-height: 1.6;"></textarea>
          <small style="color: var(--text-muted); font-size: 11px; margin-top: 6px;">
            Supports Markdown: # headers, **bold**, *italic*, - lists
          </small>
        </div>
        
        <div class="form-group">
          <label>Prerequisites (Connected Nodes)</label>
          <div id="prerequisites-list" style="max-height: 150px; overflow-y: auto; padding: 12px; background: var(--bg-tertiary); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px;">
            <p style="color: var(--text-muted); font-size: 12px; margin: 0;">Drag from ports to create links</p>
          </div>
        </div>

        <button onclick="deleteSelectedNode()" class="btn btn-danger" style="width: 100%; justify-content: center; padding: 16px; font-size: 16px;">
          üóëÔ∏è Delete Node
        </button>
      </div>
      
      <div class="info-box" id="helpBox" style="margin-top: auto;">
        <p style="margin: 0; font-size: 12px; line-height: 1.6;">
          <b>üí° Quick Tips:</b><br>
          ‚Ä¢ Click and hold on <span style="color: var(--accent-success);">‚óè port</span> then drag to another port<br>
          ‚Ä¢ Shift+Click on link to delete<br>
          ‚Ä¢ Ctrl+N for new node<br>
          ‚Ä¢ Ctrl+S to save
        </p>
      </div>
    </div>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  
  <script>
    function toggleTheme() {
      document.body.classList.toggle('light-theme');
      const isLight = document.body.classList.contains('light-theme');
      localStorage.setItem('theme', isLight ? 'light' : 'dark');
      document.getElementById('theme-btn').textContent = isLight ? 'üåô' : '‚òÄÔ∏è';
    }
    
    if(localStorage.getItem('theme') === 'light') {
      document.body.classList.add('light-theme');
      document.getElementById('theme-btn').textContent = 'üåô';
    }
    
    function toggleRoadmapSettings() {
      document.getElementById('roadmapProps').classList.toggle('collapsed');
    }

    const NODE_W = 200;
    const NODE_H = 90;

    let roadmapData = { 
      id: "custom_map", 
      title: "New Roadmap", 
      description: "",
      nodes: [] 
    };
    
    let svg, gNodes, gLinks, zoom, container;
    let selectedNodeId = null;
    let drawingLine = null;
    let activePort = null;
    
    const PORTS = [
      [NODE_W/2, 0, 'top'],
      [NODE_W, NODE_H/2, 'right'],
      [NODE_W/2, NODE_H, 'bottom'],
      [0, NODE_H/2, 'left']
    ];

    function init() {
      container = document.getElementById('canvas-area');
      svg = d3.select("#svg").attr("width", "100%").attr("height", "100%");
      
      // Prevent text selection on SVG
      svg.on("mousedown", () => {
        d3.event?.preventDefault?.();
      });
      
      const defs = svg.append("defs");
      
      defs.append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 5)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "var(--accent-primary)");

      const gContainer = svg.append("g");
      gLinks = gContainer.append("g");
      gNodes = gContainer.append("g");
      
      const tempPath = gContainer.append("path").attr("class", "temp-link").attr("d", "");

      zoom = d3.zoom()
        .scaleExtent([0.1, 3])
        .on("zoom", e => gContainer.attr("transform", e.transform));
      svg.call(zoom).on("dblclick.zoom", null);
      
      svg.on("mousemove", e => {
        if(drawingLine) {
          const [mx, my] = d3.pointer(e, gContainer.node());
          tempPath.attr("d", `M${drawingLine.startX},${drawingLine.startY} L${mx},${my}`);
        }
      });

      svg.on("mouseup", (e) => {
        if(drawingLine) {
          // If mouseup not on a port, cancel drawing
          if (!d3.select(e.target).classed('port')) {
            console.log('Cancelled drawing - mouseup not on port');
            drawingLine = null;
            tempPath.attr("d", "");
            gNodes.selectAll('.port').classed('active', false);
          }
        }
      });

      svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
      render();
      updateCounts();
    }

    function hexToRgba(hex, opacity) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity / 100})`;
    }

    function updateNodeColor() {
      if(!selectedNodeId) return;
      
      const color = document.getElementById('nodeColor').value;
      const opacity = document.getElementById('nodeOpacity').value;
      const rgba = hexToRgba(color, opacity);
      
      document.getElementById('opacityValue').textContent = opacity + '%';
      document.getElementById('colorPreview').style.background = rgba;
      
      const node = roadmapData.nodes.find(x => x.id === selectedNodeId);
      node.color = color;
      node.opacity = parseFloat(opacity) / 100;
      
      render();
    }

    function render() {
      const links = [];
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) {
          n.prerequisites.forEach(pId => {
            const src = roadmapData.nodes.find(x => x.id === pId);
            if(src) links.push({ src, tgt: n });
          });
        }
      });

      const linkSel = gLinks.selectAll(".link").data(links, d => d.src.id + "-" + d.tgt.id);
      linkSel.exit().remove();
      
      linkSel.enter().append("path")
        .attr("class", "link")
        .attr("marker-end", "url(#arrow)")
        .on("click", (e, d) => { if (e.shiftKey) deleteLink(d); })
        .on("contextmenu", (e, d) => { e.preventDefault(); deleteLink(d); })
        .merge(linkSel)
        .attr("d", d => calculateBezier(d.src, d.tgt));

      const nodeSel = gNodes.selectAll(".node-group").data(roadmapData.nodes, d => d.id);
      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter().append("g")
        .attr("class", "node-group")
        .call(d3.drag()
          .on("start", dragStart)
          .on("drag", dragging)
          .on("end", dragEnd));

      nodeEnter.append("rect")
        .attr("class", "body")
        .attr("width", NODE_W)
        .attr("height", NODE_H)
        .attr("rx", 14);

      nodeEnter.append("text")
        .attr("x", NODE_W/2)
        .attr("y", NODE_H/2)
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .style("pointer-events", "none")
        .style("fill", "var(--text-primary)")
        .style("font-size", "14px")
        .style("font-weight", "600");

      // Port creation with proper data binding
      PORTS.forEach((p, idx) => {
        nodeEnter.append("circle")
          .attr("class", "port")
          .attr("cx", p[0])
          .attr("cy", p[1])
          .attr("r", 8)
          .style("pointer-events", "all")
          .on("mousedown", function(e, nodeData) {
            e.stopPropagation();
            e.preventDefault();
            startDrawing(nodeData, p);
          })
          .on("mouseup", function(e, nodeData) {
            e.stopPropagation();
            e.preventDefault();
            if (drawingLine) {
              finishDrawing(nodeData);
            }
          })
          .on("mouseenter", function() {
            if (drawingLine) {
              d3.select(this).classed('active', true);
            }
          })
          .on("mouseleave", function() {
            d3.select(this).classed('active', false);
          });
      });

      const allNodes = nodeEnter.merge(nodeSel);
      allNodes.attr("transform", d => `translate(${d.x}, ${d.y})`);
      allNodes.classed("selected", d => d.id === selectedNodeId);
      
      allNodes.select("rect.body")
        .style("fill", d => {
          const color = d.color || '#667eea';
          const opacity = d.opacity !== undefined ? d.opacity : 0.7;
          return hexToRgba(color, opacity * 100);
        })
        .style("stroke", d => d.color || '#667eea');
      
      allNodes.select("text").text(d => {
        const maxLen = 22;
        return d.title.length > maxLen ? d.title.substr(0, maxLen-3) + '...' : d.title;
      });
      
      allNodes.on("click", (e, d) => {
        if (!drawingLine) {
          e.stopPropagation();
          selectNode(d.id);
        }
      });
      
      updateCounts();
    }

    function calculateBezier(src, tgt) {
      const sx = src.x + NODE_W/2, sy = src.y + NODE_H/2;
      const tx = tgt.x + NODE_W/2, ty = tgt.y + NODE_H/2;
      const dx = tx - sx, dy = ty - sy;
      
      let start = {x: sx, y: src.y + NODE_H}, end = {x: tx, y: tgt.y};
      if (Math.abs(dx) > Math.abs(dy)) {
        start = dx > 0 ? {x: src.x + NODE_W, y: sy} : {x: src.x, y: sy};
        end = dx > 0 ? {x: tgt.x, y: ty} : {x: tgt.x + NODE_W, y: ty};
      } else {
        start = dy > 0 ? {x: sx, y: src.y + NODE_H} : {x: sx, y: src.y};
        end = dy > 0 ? {x: tx, y: tgt.y} : {x: tx, y: tgt.y + NODE_H};
      }
      const dist = Math.sqrt(dx*dx + dy*dy) * 0.5;
      return Math.abs(dy) > Math.abs(dx) 
        ? `M${start.x},${start.y} C${start.x},${start.y + dist} ${end.x},${end.y - dist} ${end.x},${end.y}`
        : `M${start.x},${start.y} C${start.x + dist},${start.y} ${end.x - dist},${end.y} ${end.x},${end.y}`;
    }

    function startDrawing(nodeData, port) {
      const node = roadmapData.nodes.find(n => n.id === nodeData.id);
      if (!node) return;
      
      drawingLine = { 
        sourceId: node.id, 
        startX: node.x + port[0], 
        startY: node.y + port[1] 
      };
      
      console.log('Started drawing from node:', node.id);
    }

    function finishDrawing(targetNodeData) {
      if (!drawingLine) return;
      
      const targetNode = roadmapData.nodes.find(n => n.id === targetNodeData.id);
      if (!targetNode) {
        console.log('Target node not found');
        drawingLine = null;
        d3.select(".temp-link").attr("d", "");
        return;
      }
      
      if (drawingLine.sourceId === targetNode.id) {
        console.log('Cannot connect node to itself');
        drawingLine = null;
        d3.select(".temp-link").attr("d", "");
        return;
      }
      
      if (!targetNode.prerequisites) targetNode.prerequisites = [];
      
      if (!targetNode.prerequisites.includes(drawingLine.sourceId)) {
        targetNode.prerequisites.push(drawingLine.sourceId);
        console.log('Created link from', drawingLine.sourceId, 'to', targetNode.id);
        render();
      } else {
        console.log('Link already exists');
      }
      
      drawingLine = null;
      d3.select(".temp-link").attr("d", "");
      gNodes.selectAll('.port').classed('active', false);
    }

    function dragStart(e, d) { 
      d3.select(this).raise(); 
      selectNode(d.id); 
    }
    
    function dragging(e, d) { 
      d.x = e.x; 
      d.y = e.y; 
      d3.select(this).attr("transform", `translate(${d.x}, ${d.y})`); 
      render(); 
    }
    
    function dragEnd(e, d) {}

    function addNewNode() {
      const id = "node_" + Date.now();
      roadmapData.nodes.push({
        id, 
        title: "New Node", 
        color: '#667eea',
        opacity: 0.7,
        content: "# New Node\n\nDescription...",
        prerequisites: [], 
        x: container.clientWidth / 2 - NODE_W/2, 
        y: container.clientHeight / 2 - NODE_H/2
      });
      render();
      selectNode(id);
    }

    function selectNode(id) {
      selectedNodeId = id;
      const n = roadmapData.nodes.find(x => x.id === id);
      if(!n) return;

      document.getElementById('roadmapProps').classList.add('collapsed');
      document.getElementById('nodeProps').style.display = 'flex';
      document.getElementById('helpBox').style.display = 'none';
      
      document.getElementById('nodeTitle').value = n.title;
      document.getElementById('nodeContent').value = n.content || '';
      
      // Update color picker
      const color = n.color || '#667eea';
      const opacity = (n.opacity !== undefined ? n.opacity : 0.7) * 100;
      
      document.getElementById('nodeColor').value = color;
      document.getElementById('nodeOpacity').value = opacity;
      document.getElementById('opacityValue').textContent = Math.round(opacity) + '%';
      document.getElementById('colorPreview').style.background = hexToRgba(color, opacity);
      
      render();
      updatePrerequisitesList();
    }

    function updatePrerequisitesList() {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (!node) return;
      const list = document.getElementById('prerequisites-list');
      const prereqs = (node.prerequisites || []).map(pId => {
        const prereqNode = roadmapData.nodes.find(n => n.id === pId);
        return prereqNode ? prereqNode.title : pId;
      });
      if (prereqs.length === 0) {
        list.innerHTML = '<p style="color: var(--text-muted); font-size: 12px; margin: 0;">No prerequisites</p>';
      } else {
        list.innerHTML = prereqs.map((title, idx) => {
          const pId = node.prerequisites[idx];
          return `<div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 6px;">
            <span style="font-size: 13px; color: var(--text-primary);">${title}</span>
            <button onclick="removePrerequisite('${pId}')" class="btn btn-danger" style="padding: 4px 10px; font-size: 12px;">√ó</button>
          </div>`;
        }).join('');
      }
    }

    function removePrerequisite(pId) {
      const node = roadmapData.nodes.find(n => n.id === selectedNodeId);
      if (node?.prerequisites) {
        node.prerequisites = node.prerequisites.filter(id => id !== pId);
        render();
        updatePrerequisitesList();
      }
    }

    function updateActiveNode() {
      if(!selectedNodeId) return;
      const n = roadmapData.nodes.find(x => x.id === selectedNodeId);
      n.title = document.getElementById('nodeTitle').value;
      n.content = document.getElementById('nodeContent').value;
      render();
    }

    function deleteSelectedNode() {
      if(!selectedNodeId || !confirm("Delete this node?")) return;
      roadmapData.nodes = roadmapData.nodes.filter(n => n.id !== selectedNodeId);
      roadmapData.nodes.forEach(n => {
        if(n.prerequisites) n.prerequisites = n.prerequisites.filter(p => p !== selectedNodeId);
      });
      selectedNodeId = null;
      document.getElementById('nodeProps').style.display = 'none';
      document.getElementById('roadmapProps').classList.remove('collapsed');
      document.getElementById('helpBox').style.display = 'block';
      render();
    }

    function deleteLink(data) {
      const tgt = roadmapData.nodes.find(n => n.id === data.tgt.id);
      if (tgt?.prerequisites) {
        tgt.prerequisites = tgt.prerequisites.filter(pid => pid !== data.src.id);
        render();
        if (selectedNodeId === data.tgt.id) updatePrerequisitesList();
      }
    }

    function downloadJSON() {
      const blob = new Blob([JSON.stringify(roadmapData, null, 2)], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (roadmapData.title || 'roadmap').replace(/\s+/g, '_') + ".json";
      a.click();
    }

    function loadJSON() { document.getElementById('load-input').click(); }

    function handleFileLoad(input) {
      const file = input.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const json = JSON.parse(e.target.result);
          if (!json.nodes) throw new Error('Invalid format');
          roadmapData = json;
          selectedNodeId = null;
          document.getElementById('mapTitle').value = json.title || 'Roadmap';
          document.getElementById('mapId').value = json.id || 'custom_map';
          document.getElementById('mapDescription').value = json.description || '';
          document.getElementById('nodeProps').style.display = 'none';
          document.getElementById('roadmapProps').classList.remove('collapsed');
          document.getElementById('helpBox').style.display = 'block';
          render();
        } catch (err) { alert("Error: " + err.message); }
      };
      reader.readAsText(file);
    }

    function updateMeta() {
      roadmapData.title = document.getElementById('mapTitle').value;
      roadmapData.id = document.getElementById('mapId').value;
      roadmapData.description = document.getElementById('mapDescription').value;
    }

    function updateCounts() {
      document.getElementById('node-count').textContent = roadmapData.nodes.length;
      document.getElementById('link-count').textContent = roadmapData.nodes.reduce((sum, n) => sum + (n.prerequisites?.length || 0), 0);
    }

    function centerView() {
      if (roadmapData.nodes.length === 0) {
        svg.call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8));
        return;
      }
      const bounds = roadmapData.nodes.reduce((acc, n) => ({
        minX: Math.min(acc.minX, n.x), maxX: Math.max(acc.maxX, n.x + NODE_W),
        minY: Math.min(acc.minY, n.y), maxY: Math.max(acc.maxY, n.y + NODE_H)
      }), { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
      const w = bounds.maxX - bounds.minX, h = bounds.maxY - bounds.minY;
      const cx = bounds.minX + w/2, cy = bounds.minY + h/2;
      const scale = Math.min((container.clientWidth * 0.8) / w, (container.clientHeight * 0.8) / h, 1);
      svg.transition().duration(750).call(zoom.transform, 
        d3.zoomIdentity.translate(container.clientWidth/2 - cx*scale, container.clientHeight/2 - cy*scale).scale(scale));
    }

    function zoomIn() { svg.transition().call(zoom.scaleBy, 1.2); }
    function zoomOut() { svg.transition().call(zoom.scaleBy, 0.8); }
    function resetZoom() { svg.transition().call(zoom.transform, d3.zoomIdentity.translate(200, 150).scale(0.8)); }

    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      if (e.key === 'Delete' || e.key === 'Backspace') { if (selectedNodeId) deleteSelectedNode(); }
      else if (e.key === 'n' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); addNewNode(); }
      else if (e.key === 's' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); downloadJSON(); }
    });

    init();
  </script>
</body>
</html>
